<!DOCTYPE html>
<html lang="en">
<body>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<h1>Chertsey Bourne (Chertsey to River Thames confluence) <b style="background-color: red;border-radius: 500px;font-size:small;">Poor Ecological Status</b></h1>
<div class="row">
    <div class="column">
        <div id="map"></div>        
    </div>
    <div class="column" style="background-color:darkgray;">

        <div id="vis"></div>
<h3>Number of Sewage Incidents in the Operational Catchment: 165</h3>
<h3>Hours of Sewage Pollution in the Operational Catchment: 2,992</h3>
  
    </div>

</div>
<!-- Create a div where the graph will take place -->
<h2 style="text-align: center;">Emotional AI Data</h2>
<div id="my_dataviz">
</div>
<div>
    <h3>Weekly Mean Saliency of Tweets on Twitter</h3>
    <p style="width: 100%;">  Each tweet includes a score between 5 for extremely positive and -5 for extremely 
        negative (but tweets will usually fall somewhere in between). Then, we aggregate tweets at 
        four geographical scales, namely river basin district, management catchment, operational 
        catchment, and water body. </p>
    <a href="#">View Raw Data</a>
</div>
<div class="row">
    <div class="column">
        <div id="my_dataviz1">
            <h3>Emotions detected in tweets (% of total tweets)</h3>
            <p>Emotions are defined though NRC Emotional Lexiocon</p>
            <a href="#">View Raw Data</a>
        </div>
    </div>
    <div class="column">
        <div id="my_dataviz4">
            <h3>Common phrases associated with the water body </h3>
            <a href="#">View Raw Data</a>
        </div>
    </div>
  </div>
</div>


    <style>
        body{
            background-color: #002147;
            color: white;
        }
        path {
            stroke: #fff;

        }
        table {
                border-collapse: collapse;
                border: 2px black solid;
                font: 12px sans-serif;
            }

            td {
                border: 1px black solid;
                padding: 5px;
            }
        .row {
  display: flex;
}
body { margin: 0; padding: 0; }
#map { height: 60vh; width: 100%; }
.column {
  flex: 50%;
}
svg {
    display: block;
    margin: 0 auto;
}
    </style>

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
    <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3.layout.cloud.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.6.1/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-geo@3"></script>

<script>
    	mapboxgl.accessToken = 'pk.eyJ1IjoibmF0aGFuYWVsaXNhbWFwcGVyIiwiYSI6ImNrODNiZzdoZTA4Y2gzZ281YmJiMHNwOWIifQ.d2ntY86sJ7DR7011dUJ2cw';
const map = new mapboxgl.Map({
container: 'map', // container ID
style: 'mapbox://styles/nathanaelisamapper/ckz1x0r54001514tbrxvqosch', // style URL
center: [	-0.076132, 	51.508530], // starting position [lng, lat]
zoom: 13, // starting zoom,
pitch: 75
});

map.on('load', () => {
map.addSource('wb', {
            'type': 'geojson',
            'data': 'data/lines.geojson'
        });

        map.addLayer({
            'id': 'wb_value',
            'source': 'wb',
            'maxzoom': 20,
            'minzoom': 2,
            'type': 'line',
            'paint': {
                'line-width': 5,
                'line-color': [
                    'interpolate',
                    ['linear'],
                    ['get', 'group'],
                    1,
                    '#b92727',
                    2,
                    '#f2ee0f',
                    3,
                    '#1a8812'
                ]
            }
        });

    })


</script>

    <script>
        // set the dimensions and margins of the graph
        var margin = {
                top: 10,
                right: 30,
                bottom: 30,
                left: 60
            },
            width = 1200 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#my_dataviz")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        //Read the data for graph
        d3.csv("https://raw.githubusercontent.com/Digital-Water-Publics/Thames21-Socio-Ecological-Data/main/pot-mi/Open-Data/Thames/GB106037028080/polarity-score.csv",

            // When reading the csv, I must format variables:
            function (d) {
                return {
                    date: d3.timeParse("%Y-%m-%d")(d.created_at),
                    value: d.mean_senti
                }
            },

            // Now I can use this dataset:
            // Now I can use this dataset:
            function (data) {

                // Add X axis --> it is a date format
                var x = d3.scaleTime()
                    .domain(d3.extent(data, function (d) {
                        return d.date;
                    }))
                    .range([0, width]);
                xAxis = svg.append("g")
                .style("stroke", "white")
                .style("font-size", "16px")
                .style("font-family", "'M PLUS Rounded 1c', sans-serif")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));

                // Add Y axis
                var y = d3.scaleLinear()
                    .domain([-5, d3.max(data, function (d) {
                        return +d.value;
                    })])
                    .range([height, 0]);
                yAxis = svg.append("g")
                .style("stroke", "white")
                .style("font-family", "'M PLUS Rounded 1c', sans-serif")
                .style("font-size", "16px")
                    .call(d3.axisLeft(y));

                // Add a clipPath: everything out of this area won't be drawn.
                var clip = svg.append("defs").append("svg:clipPath")
                    .attr("id", "clip")
                    .append("svg:rect")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("x", 0)
                    .attr("y", 0);

                // Add brushing
                var brush = d3.brushX() // Add the brush feature using the d3.brush function
                    .extent([
                        [0, 0],
                        [width, height]
                    ]) // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
                    .on("end",
                    updateChart) // Each time the brush selection changes, trigger the 'updateChart' function

                // Create the line variable: where both the line and the brush take place
                var line = svg.append('g')
                    .attr("clip-path", "url(#clip)")

                // Add the line
                line.append("path")
                    .datum(data)
                    .attr("class", "line") // I add the class line to be able to modify this line later on.
                    .attr("fill", "none")
                    .attr("stroke", "steelblue")
                    .attr("stroke-width", 1.5)
                    .attr("d", d3.line()
                        .x(function (d) {
                            return x(d.date)
                        })
                        .y(function (d) {
                            return y(d.value)
                        })
                    )

                // Add the brushing
                line
                    .append("g")
                    .attr("class", "brush")
                    .call(brush);

                // A function that set idleTimeOut to null
                var idleTimeout

                function idled() {
                    idleTimeout = null;
                }

                // A function that update the chart for given boundaries
                function updateChart() {

                    // What are the selected boundaries?
                    extent = d3.event.selection

                    // If no selection, back to initial coordinate. Otherwise, update X axis domain
                    if (!extent) {
                        if (!idleTimeout) return idleTimeout = setTimeout(idled,
                        350); // This allows to wait a little bit
                        x.domain([4, 8])
                    } else {
                        x.domain([x.invert(extent[0]), x.invert(extent[1])])
                        line.select(".brush").call(brush.move,
                            null) // This remove the grey brush area as soon as the selection has been done
                    }

                    // Update axis and line position
                    xAxis.transition().duration(1000).call(d3.axisBottom(x))
                    line
                        .select('.line')
                        .transition()
                        .duration(1000)
                        .attr("d", d3.line()
                            .x(function (d) {
                                return x(d.date)
                            })
                            .y(function (d) {
                                return y(d.value)
                            })
                        )
                }

                // If user double click, reinitialize the chart
                svg.on("dblclick", function () {
                    x.domain(d3.extent(data, function (d) {
                        return d.date;
                    }))
                    xAxis.transition().call(d3.axisBottom(x))
                    line
                        .select('.line')
                        .transition()
                        .attr("d", d3.line()
                            .x(function (d) {
                                return x(d.date)
                            })
                            .y(function (d) {
                                return y(d.value)
                            })
                        )
                });

            })
    </script>


    <script>
        // set the dimensions and margins of the graph
        var margin1 = {
            top: 20,
      right: 20,
      bottom: 40,
      left: 185
            },
            width1 = 550 - margin.left - margin.right,
            height2 = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg1 = d3.select("#my_dataviz1")
            .append("svg")
            .attr("width", width1 + margin1.left + margin1.right)
            .attr("height", height2 + margin1.top + margin1.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin1.left + "," + margin1.top + ")");

        // Parse the Data
        d3.csv("https://raw.githubusercontent.com/Digital-Water-Publics/Thames21-Socio-Ecological-Data/main/pot-mi/Open-Data/Thames/GB106037028080/emolex-frequency.csv", function (data) {

            // Add X axis
            var x = d3.scaleLinear()
                .domain([0, 50])
                .range([0, width]);
            svg1.append("g")
                .attr("transform", "translate(0," + height + ")")
                .style("stroke", "white")
                .style("font-family", "'M PLUS Rounded 1c', sans-serif")
                .style("font-size", "16px")
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end");

            // Y axis
            var y = d3.scaleBand()
                .range([0, height])
                .domain(data.map(function (d) {
                    return d.sentiment;
                }))
                .padding(.1);
            svg1.append("g")
                .style("stroke", "white")
                .style("font-size", "16px")
                .style("font-family", "'M PLUS Rounded 1c', sans-serif")
                .call(d3.axisLeft(y))

            //Bars
            svg1.selectAll("myRect")
                .data(data)
                .enter()
                .append("rect")
                .attr("x", x(0))
                .attr("y", function (d) {
                    return y(d.sentiment);
                })
                .attr("width", function (d) {
                    return x(d.percent);
                })
                .attr("height", y.bandwidth())
                .attr("fill", "white")

        })
    </script>

    <script>
        // set the dimensions and margins of the graph
        var margin5 = {
            top: 20,
      right: 45,
      bottom: 20,
      left: 20
            },
            width3 = 500 - margin.left - margin.right,
            height3 = 400 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg4 = d3.select("#my_dataviz4").append("svg")
            .attr("width", width3 + margin5.left + margin5.right)
            .attr("height", height3 + margin5.top + margin5.bottom)
            .append("g");

        d3.csv("https://raw.githubusercontent.com/Digital-Water-Publics/Thames21-Socio-Ecological-Data/main/pot-mi/Open-Data/Thames/GB106037028080/common-nounphrase.csv", function (data) {


                // Constructs a new cloud layout instance. It run an algorithm to find the position of words that suits your requirements
                // Wordcloud features that are different from one word to the other must be here
                var layout = d3.layout.cloud()
                    .size([width3, height3])
                    .words(data.map(function (d) {
                        return {
                            text: d.text
                        };
                    }))
                    .padding(5) //space between words
                    .rotate(0) // rotation angle in degrees
                    .fontSize(32) // font size of words
                    .on("end", draw);
                layout.start();

                // This function takes the output of 'layout' above and draw the words
                // Wordcloud features that are THE SAME from one word to the other can be here
                function draw(words) {
                    svg4
                        .append("g")
                        .attr("transform", "translate(" + layout.size()[0] / 2 + "," + layout.size()[1] / 2 + ")")
                        .selectAll("text")
                        .data(words)
                        .enter().append("text")
                        .style("font-size", "2em")
                        .style("fill", "white")
                        .attr("text-anchor", "middle")
                        .style("font-family", "'M PLUS Rounded 1c', sans-serif")
                        .attr("transform", function (d) {
                            return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                        })
                        .text(function (d) {
                            return d.text;
                        })
                };
            
        });
    </script>
<!-- 
    <script>
            


    d3.text("https://raw.githubusercontent.com/Digital-Water-Publics/pot-mi/main/pot-mi/se.csv", function(data) {
                var parsedCSV = d3.csv(data);

                var container = d3.select("#vis")
                    .append("table")

                    .selectAll("tr")
                        .data(data).enter()
                        .append("tr")

                    .selectAll("td")
                        .data(function(d) { return d; }).enter()
                        .append("td")
                        .text(function(d) { return d; });
            });
    </script> -->

</body>

</html>